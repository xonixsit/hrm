<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Break Time Fix Verification</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 p-8">
    <div id="app">
        <div class="max-w-4xl mx-auto">
            <h1 class="text-3xl font-bold text-gray-900 mb-8">Break Time Fix Verification</h1>
            
            <!-- Simulated Dashboard -->
            <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
                <h2 class="text-xl font-semibold mb-4">Employee Dashboard Simulation</h2>
                
                <!-- Time Display -->
                <div class="grid grid-cols-3 gap-4 mb-6 p-4 bg-gray-50 rounded-lg">
                    <div class="text-center">
                        <div class="text-xs text-gray-500 uppercase tracking-wide font-medium mb-1">Work Time</div>
                        <div class="text-lg font-bold text-gray-900 font-mono">{{ workDuration }}</div>
                    </div>
                    <div class="text-center" v-if="onBreak">
                        <div class="text-xs text-gray-500 uppercase tracking-wide font-medium mb-1">Break Time</div>
                        <div class="text-lg font-bold text-gray-900 font-mono">{{ breakDuration }}</div>
                    </div>
                    <div class="text-center">
                        <div class="text-xs text-gray-500 uppercase tracking-wide font-medium mb-1">Status</div>
                        <div class="text-lg font-bold" :class="statusColor">{{ status }}</div>
                    </div>
                </div>
                
                <!-- Control Buttons -->
                <div class="flex space-x-4 mb-6">
                    <button 
                        @click="clockIn" 
                        :disabled="clockedIn"
                        class="px-4 py-2 bg-green-600 text-white rounded-lg disabled:opacity-50 disabled:cursor-not-allowed hover:bg-green-700"
                    >
                        Clock In
                    </button>
                    <button 
                        @click="takeBreak" 
                        :disabled="!clockedIn || onBreak"
                        class="px-4 py-2 bg-yellow-600 text-white rounded-lg disabled:opacity-50 disabled:cursor-not-allowed hover:bg-yellow-700"
                    >
                        Take Break
                    </button>
                    <button 
                        @click="endBreak" 
                        :disabled="!onBreak"
                        class="px-4 py-2 bg-blue-600 text-white rounded-lg disabled:opacity-50 disabled:cursor-not-allowed hover:bg-blue-700"
                    >
                        End Break
                    </button>
                    <button 
                        @click="clockOut" 
                        :disabled="!clockedIn"
                        class="px-4 py-2 bg-red-600 text-white rounded-lg disabled:opacity-50 disabled:cursor-not-allowed hover:bg-red-700"
                    >
                        Clock Out
                    </button>
                </div>
                
                <!-- Debug Info -->
                <div class="bg-gray-100 p-4 rounded-lg">
                    <h3 class="font-semibold mb-2">Debug Information:</h3>
                    <div class="text-sm space-y-1">
                        <div><strong>Clocked In:</strong> {{ clockedIn }}</div>
                        <div><strong>On Break:</strong> {{ onBreak }}</div>
                        <div><strong>Clock In Time:</strong> {{ clockInTime || 'Not clocked in' }}</div>
                        <div><strong>Break Start Time:</strong> {{ breakStartTime || 'Not on break' }}</div>
                        <div><strong>Current Time:</strong> {{ currentTime }}</div>
                    </div>
                </div>
            </div>
            
            <!-- Test Results -->
            <div class="bg-white rounded-lg shadow-lg p-6">
                <h2 class="text-xl font-semibold mb-4">Test Results</h2>
                <div class="space-y-2">
                    <div v-for="result in testResults" :key="result.id" class="flex items-center space-x-2">
                        <div class="w-4 h-4 rounded-full" :class="result.passed ? 'bg-green-500' : 'bg-red-500'"></div>
                        <span>{{ result.description }}</span>
                        <span v-if="!result.passed" class="text-red-600 text-sm">({{ result.error }})</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const { createApp, ref, computed, onMounted, onUnmounted } = Vue;

        createApp({
            setup() {
                // State
                const clockedIn = ref(false);
                const onBreak = ref(false);
                const clockInTime = ref(null);
                const breakStartTime = ref(null);
                const currentTime = ref(new Date().toLocaleTimeString());
                const workDuration = ref('0h 0m 0s');
                const breakDuration = ref('0h 0m 0s');
                const testResults = ref([]);
                
                let timeInterval = null;
                
                // Computed
                const status = computed(() => {
                    if (!clockedIn.value) return 'Not Clocked In';
                    if (onBreak.value) return 'On Break';
                    return 'Working';
                });
                
                const statusColor = computed(() => {
                    if (!clockedIn.value) return 'text-gray-600';
                    if (onBreak.value) return 'text-yellow-600';
                    return 'text-green-600';
                });
                
                // Methods
                const updateTime = () => {
                    const now = new Date();
                    currentTime.value = now.toLocaleTimeString();
                    
                    // Update work duration
                    if (clockedIn.value && clockInTime.value) {
                        const clockIn = new Date(clockInTime.value);
                        const diffMs = now - clockIn;
                        const hours = Math.floor(diffMs / (1000 * 60 * 60));
                        const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
                        const seconds = Math.floor((diffMs % (1000 * 60)) / 1000);
                        workDuration.value = `${hours}h ${minutes}m ${seconds}s`;
                    } else {
                        workDuration.value = '0h 0m 0s';
                    }
                    
                    // Update break duration - this is the key fix
                    if (onBreak.value && breakStartTime.value) {
                        const breakStart = new Date(breakStartTime.value);
                        if (!isNaN(breakStart.getTime())) {
                            const diffMs = Math.max(0, now - breakStart);
                            const hours = Math.floor(diffMs / (1000 * 60 * 60));
                            const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
                            const seconds = Math.floor((diffMs % (1000 * 60)) / 1000);
                            breakDuration.value = `${hours}h ${minutes}m ${seconds}s`;
                        } else {
                            breakDuration.value = '0h 0m 1s'; // Show at least 1 second
                        }
                    } else {
                        breakDuration.value = '0h 0m 0s';
                    }
                };
                
                const clockIn = () => {
                    clockedIn.value = true;
                    clockInTime.value = new Date().toISOString();
                    runTest('Clock In', () => {
                        return clockedIn.value && clockInTime.value;
                    });
                };
                
                const takeBreak = () => {
                    if (!clockedIn.value) return;
                    
                    onBreak.value = true;
                    breakStartTime.value = new Date().toISOString(); // Immediate feedback
                    
                    // Test that break time starts updating immediately
                    setTimeout(() => {
                        runTest('Break Time Updates', () => {
                            return breakDuration.value !== '0h 0m 0s';
                        });
                    }, 1100); // Wait just over 1 second
                };
                
                const endBreak = () => {
                    onBreak.value = false;
                    breakStartTime.value = null;
                    runTest('End Break', () => {
                        return !onBreak.value && breakDuration.value === '0h 0m 0s';
                    });
                };
                
                const clockOut = () => {
                    clockedIn.value = false;
                    onBreak.value = false;
                    clockInTime.value = null;
                    breakStartTime.value = null;
                    runTest('Clock Out', () => {
                        return !clockedIn.value && workDuration.value === '0h 0m 0s';
                    });
                };
                
                const runTest = (description, testFn) => {
                    try {
                        const passed = testFn();
                        testResults.value.push({
                            id: Date.now(),
                            description,
                            passed,
                            error: passed ? null : 'Test condition failed'
                        });
                    } catch (error) {
                        testResults.value.push({
                            id: Date.now(),
                            description,
                            passed: false,
                            error: error.message
                        });
                    }
                };
                
                // Lifecycle
                onMounted(() => {
                    updateTime();
                    timeInterval = setInterval(updateTime, 1000);
                    
                    // Initial test
                    runTest('Initial State', () => {
                        return !clockedIn.value && !onBreak.value;
                    });
                });
                
                onUnmounted(() => {
                    if (timeInterval) {
                        clearInterval(timeInterval);
                    }
                });
                
                return {
                    clockedIn,
                    onBreak,
                    clockInTime,
                    breakStartTime,
                    currentTime,
                    workDuration,
                    breakDuration,
                    status,
                    statusColor,
                    testResults,
                    clockIn,
                    takeBreak,
                    endBreak,
                    clockOut
                };
            }
        }).mount('#app');
    </script>
</body>
</html>