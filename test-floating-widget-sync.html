<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Floating Widget Sync Test</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f8fafc;
        }
        .test-container {
            max-width: 800px;
            margin: 2rem auto;
            padding: 2rem;
        }
        .widget-demo {
            background: white;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            margin-bottom: 24px;
            border: 1px solid #e5e7eb;
        }
        
        /* Time Display Section styles */
        .time-display-section {
            padding: 24px;
            background: white;
            border-bottom: 1px solid #f3f4f6;
        }
        
        .time-metrics {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 24px;
        }
        
        .time-metric {
            text-align: center;
        }
        
        .time-value {
            font-size: 24px;
            font-weight: 700;
            color: #111827;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            margin-bottom: 4px;
        }
        
        .time-label {
            font-size: 11px;
            color: #6b7280;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .btn {
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            border: none;
            cursor: pointer;
            transition: all 0.2s;
            margin-right: 8px;
            margin-bottom: 8px;
        }
        .btn-primary { background: #3b82f6; color: white; }
        .btn-primary:hover { background: #2563eb; }
        .btn-secondary { background: #f3f4f6; color: #374151; }
        .btn-secondary:hover { background: #e5e7eb; }
        .btn-break { background: #fbbf24; color: #92400e; }
        .btn-break:hover { background: #f59e0b; }
        
        .test-log {
            background: #1f2937;
            color: #e5e7eb;
            padding: 16px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
            margin-top: 16px;
        }
        
        .sync-status {
            background: #f0f9ff;
            border: 1px solid #0ea5e9;
            color: #0c4a6e;
            padding: 12px;
            border-radius: 8px;
            margin-top: 16px;
        }
        
        .floating-widget-sim {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: white;
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            border: 1px solid #e5e7eb;
            min-width: 200px;
        }
    </style>
</head>
<body>
    <div id="app">
        <div class="test-container">
            <h1 class="text-3xl font-bold text-gray-900 mb-6">Floating Widget Sync Test</h1>
            
            <div class="widget-demo">
                <h2 class="text-xl font-semibold mb-4">Main ClockInOutWidget (Top)</h2>
                
                <!-- Time Display Section (Main Widget) -->
                <div v-if="mainWidget.clockedIn" class="time-display-section">
                    <div class="time-metrics">
                        <div class="time-metric">
                            <div class="time-value">{{ mainWidget.workTime }}</div>
                            <div class="time-label">WORK TIME</div>
                        </div>
                        <div class="time-metric">
                            <div class="time-value">{{ mainWidget.breakTime }}</div>
                            <div class="time-label">BREAK TIME</div>
                        </div>
                        <div class="time-metric">
                            <div class="time-value">{{ mainWidget.progress }}%</div>
                            <div class="time-label">PROGRESS</div>
                        </div>
                    </div>
                </div>
                
                <!-- Action Buttons -->
                <div class="mt-4">
                    <button 
                        @click="mainWidget.toggleClockInOut" 
                        :class="['btn', mainWidget.clockedIn ? 'btn-secondary' : 'btn-primary']"
                    >
                        {{ mainWidget.clockedIn ? 'Clock Out' : 'Clock In' }}
                    </button>
                    
                    <button 
                        v-if="mainWidget.clockedIn"
                        @click="mainWidget.toggleBreak" 
                        :class="['btn', mainWidget.onBreak ? 'btn-secondary' : 'btn-break']"
                    >
                        {{ mainWidget.onBreak ? 'End Break' : 'Take Break' }}
                    </button>
                </div>
                
                <!-- Sync Status -->
                <div class="sync-status">
                    <h3 class="font-semibold mb-2">Main Widget State:</h3>
                    <ul class="text-sm space-y-1">
                        <li><strong>Clocked In:</strong> {{ mainWidget.clockedIn ? 'Yes' : 'No' }}</li>
                        <li><strong>On Break:</strong> {{ mainWidget.onBreak ? 'Yes' : 'No' }}</li>
                        <li><strong>Work Time:</strong> {{ mainWidget.workTime }}</li>
                        <li><strong>Break Time:</strong> {{ mainWidget.breakTime }}</li>
                        <li><strong>Total Break Minutes:</strong> {{ mainWidget.totalBreakMinutes }}</li>
                    </ul>
                </div>
            </div>
            
            <div class="widget-demo">
                <h2 class="text-xl font-semibold mb-4">Sync Test Controls</h2>
                <div class="space-y-4">
                    <button @click="testSync" class="btn btn-primary">Test Sync Between Widgets</button>
                    <button @click="simulateFloatingWidgetAction" class="btn btn-secondary">Simulate Floating Widget Action</button>
                    <button @click="checkSyncStatus" class="btn btn-secondary">Check Sync Status</button>
                </div>
                
                <!-- Test Log -->
                <div class="test-log">
                    <div v-for="log in logs" :key="log.id" class="mb-1">
                        <span class="text-blue-400">[{{ log.time }}]</span> {{ log.message }}
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Simulated Floating Widget -->
        <div class="floating-widget-sim">
            <h3 class="font-semibold text-sm mb-2">Floating Widget</h3>
            <div class="text-xs space-y-1">
                <div><strong>Status:</strong> {{ floatingWidget.clockedIn ? (floatingWidget.onBreak ? 'On Break' : 'Working') : 'Clocked Out' }}</div>
                <div><strong>Work:</strong> {{ floatingWidget.workTime }}</div>
                <div><strong>Break:</strong> {{ floatingWidget.breakTime }}</div>
            </div>
            <div class="mt-2 space-x-1">
                <button @click="floatingWidget.toggleClockInOut" class="text-xs px-2 py-1 bg-blue-500 text-white rounded">
                    {{ floatingWidget.clockedIn ? 'Out' : 'In' }}
                </button>
                <button v-if="floatingWidget.clockedIn" @click="floatingWidget.toggleBreak" class="text-xs px-2 py-1 bg-yellow-500 text-white rounded">
                    {{ floatingWidget.onBreak ? 'End' : 'Break' }}
                </button>
            </div>
        </div>
    </div>

    <script>
        const { createApp, ref, computed, onMounted, onUnmounted, reactive } = Vue;

        createApp({
            setup() {
                // Shared state (simulating the useAttendanceSync composable)
                const sharedState = reactive({
                    clockedIn: false,
                    onBreak: false,
                    clockInTime: null,
                    breakStartTime: null,
                    totalBreakMinutes: 0,
                    breakSessions: []
                });
                
                const logs = ref([]);
                
                // Timer
                let timer = null;
                
                // Computed properties for shared state
                const sharedComputed = {
                    workTime: computed(() => {
                        if (!sharedState.clockedIn || !sharedState.clockInTime) {
                            return '0h 0m 0s';
                        }
                        
                        const now = new Date();
                        const start = new Date(sharedState.clockInTime);
                        const totalMs = now - start;
                        
                        // Subtract all break time
                        let breakMs = sharedState.totalBreakMinutes * 60 * 1000;
                        
                        // Add current break if on break
                        if (sharedState.onBreak && sharedState.breakStartTime) {
                            const currentBreakMs = now - new Date(sharedState.breakStartTime);
                            breakMs += currentBreakMs;
                        }
                        
                        const workMs = Math.max(0, totalMs - breakMs);
                        return formatDuration(workMs);
                    }),
                    
                    breakTime: computed(() => {
                        if (!sharedState.clockedIn) {
                            return '0h 0m 0s';
                        }
                        
                        if (sharedState.onBreak && sharedState.breakStartTime) {
                            // Show current break session duration
                            const now = new Date();
                            const currentBreakMs = now - new Date(sharedState.breakStartTime);
                            return formatDuration(currentBreakMs);
                        } else {
                            // Show accumulated break time
                            const totalBreakMs = sharedState.totalBreakMinutes * 60 * 1000;
                            return formatDuration(totalBreakMs);
                        }
                    }),
                    
                    progress: computed(() => {
                        if (!sharedState.clockedIn || !sharedState.clockInTime) {
                            return 0;
                        }
                        
                        const now = new Date();
                        const start = new Date(sharedState.clockInTime);
                        const totalMs = now - start;
                        
                        if (totalMs === 0) return 0;
                        
                        let breakMs = sharedState.totalBreakMinutes * 60 * 1000;
                        if (sharedState.onBreak && sharedState.breakStartTime) {
                            breakMs += now - new Date(sharedState.breakStartTime);
                        }
                        
                        const workMs = Math.max(0, totalMs - breakMs);
                        const workHours = workMs / (1000 * 60 * 60);
                        
                        return Math.min(Math.round((workHours / 8) * 100), 100);
                    })
                };
                
                // Main widget (should use shared state)
                const mainWidget = {
                    clockedIn: computed(() => sharedState.clockedIn),
                    onBreak: computed(() => sharedState.onBreak),
                    workTime: sharedComputed.workTime,
                    breakTime: sharedComputed.breakTime,
                    progress: sharedComputed.progress,
                    totalBreakMinutes: computed(() => sharedState.totalBreakMinutes),
                    
                    toggleClockInOut: () => {
                        if (sharedState.clockedIn) {
                            // Clock out
                            if (sharedState.onBreak) {
                                endBreak();
                            }
                            sharedState.clockedIn = false;
                            sharedState.clockInTime = null;
                            addLog('Main Widget: Clocked out');
                        } else {
                            // Clock in
                            sharedState.clockedIn = true;
                            sharedState.clockInTime = new Date().toISOString();
                            addLog('Main Widget: Clocked in');
                        }
                        broadcastStateChange();
                    },
                    
                    toggleBreak: () => {
                        if (sharedState.onBreak) {
                            endBreak();
                            addLog('Main Widget: Ended break');
                        } else {
                            startBreak();
                            addLog('Main Widget: Started break');
                        }
                        broadcastStateChange();
                    }
                };
                
                // Floating widget (should use same shared state)
                const floatingWidget = {
                    clockedIn: computed(() => sharedState.clockedIn),
                    onBreak: computed(() => sharedState.onBreak),
                    workTime: sharedComputed.workTime,
                    breakTime: sharedComputed.breakTime,
                    
                    toggleClockInOut: () => {
                        if (sharedState.clockedIn) {
                            // Clock out
                            if (sharedState.onBreak) {
                                endBreak();
                            }
                            sharedState.clockedIn = false;
                            sharedState.clockInTime = null;
                            addLog('Floating Widget: Clocked out');
                        } else {
                            // Clock in
                            sharedState.clockedIn = true;
                            sharedState.clockInTime = new Date().toISOString();
                            addLog('Floating Widget: Clocked in');
                        }
                        broadcastStateChange();
                    },
                    
                    toggleBreak: () => {
                        if (sharedState.onBreak) {
                            endBreak();
                            addLog('Floating Widget: Ended break');
                        } else {
                            startBreak();
                            addLog('Floating Widget: Started break');
                        }
                        broadcastStateChange();
                    }
                };
                
                // Helper functions
                const formatDuration = (ms) => {
                    const totalSeconds = Math.floor(ms / 1000);
                    const hours = Math.floor(totalSeconds / 3600);
                    const minutes = Math.floor((totalSeconds % 3600) / 60);
                    const seconds = totalSeconds % 60;
                    return `${hours}h ${minutes}m ${seconds}s`;
                };
                
                const addLog = (message) => {
                    const now = new Date();
                    logs.value.unshift({
                        id: Date.now(),
                        time: now.toLocaleTimeString(),
                        message
                    });
                    
                    if (logs.value.length > 15) {
                        logs.value = logs.value.slice(0, 15);
                    }
                };
                
                const startBreak = () => {
                    if (!sharedState.clockedIn || sharedState.onBreak) return;
                    
                    sharedState.onBreak = true;
                    sharedState.breakStartTime = new Date().toISOString();
                };
                
                const endBreak = () => {
                    if (!sharedState.onBreak || !sharedState.breakStartTime) return;
                    
                    const now = new Date();
                    const breakStart = new Date(sharedState.breakStartTime);
                    const breakDurationMs = now - breakStart;
                    const breakDurationMinutes = Math.floor(breakDurationMs / (1000 * 60));
                    
                    // Add to break sessions
                    sharedState.breakSessions.push({
                        start: sharedState.breakStartTime,
                        end: now.toISOString(),
                        duration_minutes: breakDurationMinutes
                    });
                    
                    // Update total break minutes
                    sharedState.totalBreakMinutes += breakDurationMinutes;
                    
                    // Reset break state
                    sharedState.onBreak = false;
                    sharedState.breakStartTime = null;
                    
                    addLog(`Break ended: ${breakDurationMinutes} minutes added to total`);
                };
                
                const broadcastStateChange = () => {
                    addLog('State change broadcasted to all widgets');
                };
                
                // Test functions
                const testSync = () => {
                    addLog('=== SYNC TEST STARTED ===');
                    addLog('Testing if both widgets show the same data...');
                    
                    const mainWorkTime = mainWidget.workTime.value;
                    const floatingWorkTime = floatingWidget.workTime.value;
                    const mainBreakTime = mainWidget.breakTime.value;
                    const floatingBreakTime = floatingWidget.breakTime.value;
                    
                    addLog(`Main Widget - Work: ${mainWorkTime}, Break: ${mainBreakTime}`);
                    addLog(`Floating Widget - Work: ${floatingWorkTime}, Break: ${floatingBreakTime}`);
                    
                    if (mainWorkTime === floatingWorkTime && mainBreakTime === floatingBreakTime) {
                        addLog('✅ SYNC SUCCESS: Both widgets show identical data');
                    } else {
                        addLog('❌ SYNC FAILURE: Widgets show different data');
                    }
                };
                
                const simulateFloatingWidgetAction = () => {
                    addLog('Simulating floating widget action...');
                    if (!sharedState.clockedIn) {
                        floatingWidget.toggleClockInOut();
                    } else {
                        floatingWidget.toggleBreak();
                    }
                    
                    setTimeout(() => {
                        addLog('Checking if main widget updated...');
                        testSync();
                    }, 100);
                };
                
                const checkSyncStatus = () => {
                    addLog('=== SYNC STATUS CHECK ===');
                    addLog(`Shared State - Clocked In: ${sharedState.clockedIn}, On Break: ${sharedState.onBreak}`);
                    addLog(`Main Widget - Clocked In: ${mainWidget.clockedIn.value}, On Break: ${mainWidget.onBreak.value}`);
                    addLog(`Floating Widget - Clocked In: ${floatingWidget.clockedIn.value}, On Break: ${floatingWidget.onBreak.value}`);
                    addLog(`Total Break Minutes: ${sharedState.totalBreakMinutes}`);
                };
                
                // Start timer for real-time updates
                onMounted(() => {
                    timer = setInterval(() => {
                        // Force reactivity update for computed properties
                    }, 1000);
                    
                    addLog('Sync test initialized');
                    addLog('This demonstrates how shared state should work between widgets');
                });
                
                onUnmounted(() => {
                    if (timer) clearInterval(timer);
                });
                
                return {
                    mainWidget,
                    floatingWidget,
                    logs,
                    testSync,
                    simulateFloatingWidgetAction,
                    checkSyncStatus
                };
            }
        }).mount('#app');
    </script>
</body>
</html>