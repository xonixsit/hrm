<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-time Work Duration Test</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 min-h-screen py-8">
    <div id="app" class="container mx-auto px-4">
        <div class="max-w-md mx-auto bg-white rounded-lg shadow-lg p-6">
            <h1 class="text-2xl font-bold text-center mb-6">Real-time Work Duration Test</h1>
            
            <!-- Current Time Display -->
            <div class="text-center mb-6 p-4 bg-gray-50 rounded-lg">
                <div class="text-3xl font-mono font-bold text-gray-900">{{ currentTime }}</div>
                <div class="text-sm text-gray-600 mt-1">{{ currentDate }}</div>
            </div>
            
            <!-- Clock Status -->
            <div class="mb-6">
                <div class="flex items-center justify-between mb-4">
                    <div :class="['flex items-center space-x-2 px-3 py-2 rounded-lg text-sm font-medium', statusClasses]">
                        <div class="w-2 h-2 rounded-full bg-current"></div>
                        <span>{{ statusText }}</span>
                    </div>
                    <div v-if="clockedIn && realTimeWorkDuration" class="text-sm text-gray-600">
                        <span class="font-mono font-bold">{{ realTimeWorkDuration }}</span>
                    </div>
                </div>
                
                <!-- Work Progress -->
                <div v-if="clockedIn" class="mt-4 p-3 bg-blue-50 rounded-lg">
                    <div class="flex items-center justify-between mb-2">
                        <span class="text-sm font-medium text-gray-700">Work Progress</span>
                        <span class="text-sm font-bold text-gray-900">{{ workProgressPercentage }}%</span>
                    </div>
                    <div class="w-full bg-gray-200 rounded-full h-2 mb-2">
                        <div 
                            class="h-2 rounded-full transition-all duration-300"
                            :class="progressBarColor"
                            :style="{ width: workProgressPercentage + '%' }"
                        ></div>
                    </div>
                    <div class="flex items-center justify-between text-xs text-gray-600">
                        <span>{{ hoursWorked }}h worked</span>
                        <span>{{ hoursRemaining }}h remaining</span>
                    </div>
                </div>
            </div>
            
            <!-- Action Buttons -->
            <div class="space-y-3 mb-6">
                <button
                    @click="toggleClock"
                    :disabled="loading"
                    :class="clockButtonClasses"
                >
                    <span v-if="loading" class="animate-spin">‚è≥</span>
                    <span v-else-if="clockedIn">üïê</span>
                    <span v-else>‚ñ∂Ô∏è</span>
                    {{ clockButtonText }}
                </button>
                
                <button
                    v-if="clockedIn"
                    @click="toggleBreak"
                    :disabled="loading"
                    class="w-full flex items-center justify-center space-x-2 px-4 py-2 text-sm font-medium rounded-lg border border-gray-300 bg-white text-gray-700 hover:bg-gray-50 disabled:opacity-50"
                >
                    <span>‚è∏Ô∏è</span>
                    <span>{{ onBreak ? 'End Break' : 'Take Break' }}</span>
                </button>
            </div>
            
            <!-- Statistics -->
            <div class="grid grid-cols-2 gap-4 text-center">
                <div class="p-3 bg-gray-50 rounded-lg">
                    <div class="text-lg font-bold text-gray-900">{{ totalSessionTime }}</div>
                    <div class="text-xs text-gray-500">Total Session</div>
                </div>
                <div class="p-3 bg-gray-50 rounded-lg">
                    <div class="text-lg font-bold text-gray-900">{{ breakTime }}</div>
                    <div class="text-xs text-gray-500">Break Time</div>
                </div>
            </div>
            
            <!-- Test Instructions -->
            <div class="mt-6 p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
                <h3 class="font-semibold text-yellow-800 mb-2">Test Instructions:</h3>
                <ol class="text-sm text-yellow-700 space-y-1">
                    <li>1. Click "Clock In" to start tracking</li>
                    <li>2. Watch the work duration update every second</li>
                    <li>3. Try "Take Break" to pause the timer</li>
                    <li>4. Notice the progress bar updates in real-time</li>
                    <li>5. Click "Clock Out" to stop tracking</li>
                </ol>
            </div>
        </div>
    </div>

    <script>
        const { createApp, ref, computed, onMounted, onUnmounted } = Vue;

        createApp({
            setup() {
                // State
                const clockedIn = ref(false);
                const onBreak = ref(false);
                const clockInTime = ref(null);
                const breakStartTime = ref(null);
                const totalBreakTime = ref(0);
                const loading = ref(false);
                const currentTime = ref('');
                const currentDate = ref('');
                const realTimeWorkDuration = ref('0h 0m 0s');
                const dailyGoal = ref(8); // 8 hours
                
                // Intervals
                let timeInterval = null;
                let workDurationInterval = null;
                
                // Update current time
                const updateTime = () => {
                    const now = new Date();
                    currentTime.value = now.toLocaleTimeString('en-US', {
                        hour12: false,
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit'
                    });
                    currentDate.value = now.toLocaleDateString('en-US', {
                        weekday: 'long',
                        year: 'numeric',
                        month: 'long',
                        day: 'numeric'
                    });
                };
                
                // Update work duration in real-time
                const updateWorkDuration = () => {
                    if (clockedIn.value && clockInTime.value && !onBreak.value) {
                        const clockIn = new Date(clockInTime.value);
                        const now = new Date();
                        const diffMs = now - clockIn - totalBreakTime.value;
                        
                        const hours = Math.floor(diffMs / (1000 * 60 * 60));
                        const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
                        const seconds = Math.floor((diffMs % (1000 * 60)) / 1000);
                        
                        realTimeWorkDuration.value = `${hours}h ${minutes}m ${seconds}s`;
                    } else if (onBreak.value) {
                        // Keep the duration frozen during break
                        // realTimeWorkDuration.value remains the same
                    } else {
                        realTimeWorkDuration.value = '0h 0m 0s';
                    }
                };
                
                // Computed properties
                const statusText = computed(() => {
                    if (onBreak.value) return 'On Break';
                    if (clockedIn.value) return 'Clocked In';
                    return 'Clocked Out';
                });
                
                const statusClasses = computed(() => {
                    if (clockedIn.value && !onBreak.value) return 'bg-green-100 text-green-800';
                    if (onBreak.value) return 'bg-yellow-100 text-yellow-800';
                    return 'bg-gray-100 text-gray-600';
                });
                
                const clockButtonText = computed(() => {
                    if (loading.value) return 'Processing...';
                    return clockedIn.value ? 'Clock Out' : 'Clock In';
                });
                
                const clockButtonClasses = computed(() => {
                    const baseClasses = 'w-full flex items-center justify-center space-x-2 px-4 py-3 text-sm font-semibold rounded-lg disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-200';
                    return clockedIn.value
                        ? `${baseClasses} text-white bg-red-600 hover:bg-red-700`
                        : `${baseClasses} text-white bg-green-600 hover:bg-green-700`;
                });
                
                const hoursWorked = computed(() => {
                    if (!clockedIn.value || !clockInTime.value) return 0;
                    
                    const clockIn = new Date(clockInTime.value);
                    const now = new Date();
                    const diffMs = now - clockIn - totalBreakTime.value;
                    return Math.round((diffMs / (1000 * 60 * 60)) * 100) / 100;
                });
                
                const hoursRemaining = computed(() => {
                    return Math.max(dailyGoal.value - hoursWorked.value, 0);
                });
                
                const workProgressPercentage = computed(() => {
                    return Math.min(Math.round((hoursWorked.value / dailyGoal.value) * 100), 100);
                });
                
                const progressBarColor = computed(() => {
                    const percentage = workProgressPercentage.value;
                    if (percentage >= 100) return 'bg-green-500';
                    if (percentage >= 75) return 'bg-blue-500';
                    if (percentage >= 50) return 'bg-yellow-500';
                    return 'bg-gray-400';
                });
                
                const totalSessionTime = computed(() => {
                    if (!clockedIn.value || !clockInTime.value) return '0h 0m';
                    
                    const clockIn = new Date(clockInTime.value);
                    const now = new Date();
                    const diffMs = now - clockIn;
                    
                    const hours = Math.floor(diffMs / (1000 * 60 * 60));
                    const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
                    
                    return `${hours}h ${minutes}m`;
                });
                
                const breakTime = computed(() => {
                    let totalBreakMs = totalBreakTime.value;
                    
                    // Add current break time if on break
                    if (onBreak.value && breakStartTime.value) {
                        const now = new Date();
                        const breakStart = new Date(breakStartTime.value);
                        totalBreakMs += (now - breakStart);
                    }
                    
                    const hours = Math.floor(totalBreakMs / (1000 * 60 * 60));
                    const minutes = Math.floor((totalBreakMs % (1000 * 60 * 60)) / (1000 * 60));
                    
                    return `${hours}h ${minutes}m`;
                });
                
                // Methods
                const toggleClock = async () => {
                    loading.value = true;
                    
                    try {
                        await new Promise(resolve => setTimeout(resolve, 1000)); // Simulate API call
                        
                        if (clockedIn.value) {
                            // Clock out
                            clockedIn.value = false;
                            clockInTime.value = null;
                            onBreak.value = false;
                            breakStartTime.value = null;
                            totalBreakTime.value = 0;
                        } else {
                            // Clock in
                            clockedIn.value = true;
                            clockInTime.value = new Date().toISOString();
                            onBreak.value = false;
                            totalBreakTime.value = 0;
                        }
                    } finally {
                        loading.value = false;
                    }
                };
                
                const toggleBreak = async () => {
                    loading.value = true;
                    
                    try {
                        await new Promise(resolve => setTimeout(resolve, 500)); // Simulate API call
                        
                        if (onBreak.value) {
                            // End break
                            if (breakStartTime.value) {
                                const now = new Date();
                                const breakStart = new Date(breakStartTime.value);
                                totalBreakTime.value += (now - breakStart);
                            }
                            onBreak.value = false;
                            breakStartTime.value = null;
                        } else {
                            // Start break
                            onBreak.value = true;
                            breakStartTime.value = new Date().toISOString();
                        }
                    } finally {
                        loading.value = false;
                    }
                };
                
                // Lifecycle
                onMounted(() => {
                    updateTime();
                    updateWorkDuration();
                    
                    timeInterval = setInterval(updateTime, 1000);
                    workDurationInterval = setInterval(updateWorkDuration, 1000);
                });
                
                onUnmounted(() => {
                    if (timeInterval) clearInterval(timeInterval);
                    if (workDurationInterval) clearInterval(workDurationInterval);
                });
                
                return {
                    // State
                    clockedIn,
                    onBreak,
                    loading,
                    currentTime,
                    currentDate,
                    realTimeWorkDuration,
                    
                    // Computed
                    statusText,
                    statusClasses,
                    clockButtonText,
                    clockButtonClasses,
                    hoursWorked,
                    hoursRemaining,
                    workProgressPercentage,
                    progressBarColor,
                    totalSessionTime,
                    breakTime,
                    
                    // Methods
                    toggleClock,
                    toggleBreak
                };
            }
        }).mount('#app');
    </script>
</body>
</html>